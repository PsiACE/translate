---
title: Early Impressions of Go from a Rust Programmer
title-cn: 一位 Rust 程序员对 Go 的初步印象
author: ["Nick Cameron"]
translator: ["Chojan Shang(尚卓燃)"]
date: 2020-02-26
summary: Nick Cameron is a long-time Rust programmer who has recently started using Go. In this post, he talks about his early impressions of Go. Read this post to learn more.
summary-cn: Nick Cameron 是长期使用 Rust 程序员，最近开始接触 Go。在这篇文章中，他谈论了他对 Go 的初步印象。阅读这篇文章以了解更多信息。
tags: ["Go", "Rust"]
categories: ["Engineering"]
image: /images/blog/early-impressions-of-go-from-a-rust-programmer.jpg
---

![Early impressions of Go from a Rust programmer](media/early-impressions-of-go-from-a-rust-programmer.jpg)

过去几周我一直在用 [Go](<https://en.wikipedia.org/wiki/Go_(programming_language)>) 语言编写程序。 这是我第一次使用 Go 进行一个大型、严肃的项目。在研究 [Rust](<https://en.wikipedia.org/wiki/Rust_(programming_language)>) 的特性时，我也看了很多关于 Go 的内容，包括体验示例和编写玩具程序。但真正用它编程又是一种完全不同的体验。

我觉得把我的印象写下来应该会很有趣。在这篇文章中，我会尽量避免将 Go 与 Rust 进行过多的比较，但由于我从 Rust 转向 Go，或多或少会有一些。应该事先声明的是，我对 Rust 有强烈的偏爱，但会尽力做到客观。

## 总体印象

用 Go 编程的感觉很棒。库程序里有我想要的一切，总体实现较为完善。学习体验也十分顺畅，不得不说，Go 是一种经过精心设计的实用性语言。举个例子：如果你了解 Go 的语法，就会发现有许多来自其他语言的习惯用法。只要你学会一些 Go ，就可以相对轻易地预测其他功能。凭借一些来自其他语言的知识，我能够阅读并理解 Go 代码，而不需要过多的搜索。

与 C/C++、 Java、 Python 等相比，Go 并没有那么多痛点，而且更具生产力。然而，它与那一代语言具有相同的特质。尽管它从其他语言身上吸取了一些教训，甚至我个人认为它可能是那一代语言中最好的那个，但绝对还属于那一代语言。这是一种渐进式的改进，而不是推陈出新（需要明确的是，这不是意味着一种价值批判，在软件工程中，渐进式改进通常会带来好的影响）。一个很好的例证是 `nil`：像 Rust 和 Swift 这样的语言已经去除了 `null` 的概念，并且消除了相关的一整类错误。Go 降低了一部分风险：_没有空值_，在 `nil` 和 `0` 之间进行区分。但其核心思想仍未改变，解除空指针引用时的常见运行时错误正是源自于此。

## 易学性

Go 非常易学。我知道这是人们经常吹捧这一点，但是我真的为自己生产力的飞速提高而感到震惊。多亏了 Go 语言以及它的文档和工具，我仅仅花了两天时间就可以写出「有价值」、可以提交的代码。

有助于易学性的几个因素是：

- Go 很精简。很多语言都试图让自己看起来小巧，但 Go 真正做到了这一点。（这基本上是一件好事，我对这种自律精神印象深刻）
- 标准库很出色（同样，也很小）。从生态系统中寻找并使用库程序非常容易。
- 几乎没有其他语言中所不具备的东西。Go 从其他既存语言中提取了很多内容，并进行完善，最后将它们很好地组合在一起。它在避免标新立异这一方面做了极大努力。

## 乏味的样板式代码

Go 代码很快就会变得非常重复。这是由于它缺乏用于减少重复的任何机制，比如宏或者泛型（接口虽然有利于抽象，但在减少代码重复方面作用没有那么大)。我最后通常会得到很多函数，除了类型不同之外，它们甚至完全一样。

错误处理也会导致重复。许多函数中像 `if err != nil { return err }` 这样的样板式代码甚至比那些真正有价值的代码还要多。

使用泛型或宏来减少样板式代码有时会受到批评，理由是不应为使代码易于编写而使其丧失可读性。我发现 Go 恰恰提供了一个反例，复制和粘贴代码往往既快速又简单，阅读代码却会令人灰心丧气，因为你不得不忽略大量的无关代码或者在细微处刨根问底。

## 我喜欢的东西

- 编译时间：绝对快，可以确定要比 Rust 快得多。但实际上，它并没有我预期的那么快（对于中型到大型项目，我感觉它的速度只是与 C/C++ 相接近，或者稍微快一点。而我更加期待能够即时编译。）
- Go 例程和通道：值得称赞的是，Go 为编制例程和使用通道提供了轻量级的语法。尽管只是一个小细节，却使 Go 的并发编程体验比其他语言更优越，它真正揭示了语法的力量。
- 接口：它们并不复杂，但是很容易理解和使用，并且在很多地方都很很实用。
- `if ...; ... { }` 语法：可以将变量的作用域限制在 `if` 语句真的很好。这与 Swift 及 Rust 中的 `if let` 起着相似的效果，但用途更为广泛（Go 没有像 Swift 和 Rust 那样的模式匹配，所以它无法使用 `if let` 。）
- 测试和文档注释都很容易使用。
- `Go` 工具链非常友好 —— 将所有东西都放在一个地方，而不需要在命令行上使用多个工具。
- 拥有垃圾收集器（GC）！不用考虑内存管理真的会使编程更加轻松。
- 可变参数。

## 我不喜欢的东西

没有特定的顺序。

- `nil` 切片：要知道 `nil`、`nil` 切片和空切片三者都不相同，我敢保证这样的东西有两个就够了，而不需要三个。
- 没有第一类枚举：使用常量会感觉是一种倒退。
- 禁止导入循环：这实际上使得包对于模块化项目的实用程度更加有限，因为它变相鼓励了在一个包中堆积大量文件（或拥有大量零碎的小包，如果本该放在一起的文件四处分散，这也同样糟糕）。
- `switch` 语句可能并非算无遗策。
- `for ... range` 语句会返回一对「索引/值」。要想只获取索引很容易（忽略值就好）；但若要只获取值，则需要显式声明。在我看来，这种做法更应该颠倒过来，因为在大多数情况下，我更需要值而不是索引。
- 语法：
  - 定义与用途存在不一致。
  - 编译器有时会很挑剔（例如，要求或禁止尾随逗号）；通过良好的工具可以缓解这种困扰，但是有时仍然会产生一些恼人的额外步骤。
  - 使用多值返回类型时，类型上需要括号，但 `return` 语句中却不需要。
  - 声明一个结构体需要两个关键字（`type` 和 `struct`）。
  - 采用大写命名法来标记公共或私有变量，看起来就像匈牙利命名法那样，但更糟糕。
- 隐式接口。我知道它也出现在我喜欢的东西中，但有时候它确实很惹人烦——特别是当你试图找出所有实现该接口的类型，或者哪些接口是为给定类型而实现的时候。
- 你无法在不同的包中编写带有接收器的函数，所以即使接口是「鸭子类型」的，它们也不能在上游类型中实现，这使得它们的用处大大降低。

还有我之前已经提过的，Go 缺少泛型和宏。

## 一致性

作为一名语言设计者和程序员，Go 最让我惊讶的地方也许是它的内置功能和用户可用功能之间频频出现不一致。许多语言的目标之一就是尽可能消除魔法，并为用户提供可用的内置功能。运算符重载是一个简单但有争议的例子。但 Go 有很多魔法！你很容易就会遇到这样的问题: 无法做那些内置功能可以做的事情。

有些东西让我印象深刻：

- 返回多个值和通道的语法很棒，但是这两个无法一起使用，因为没有元组类型。
- 能够用 `for ... range` 语句对数组和切片进行迭代，但对其他集合就无能为力了，因为它缺乏迭代器的概念。
- 像 `len` 或者 `append` 这样的函数是全局函数，但你自己的函数却无法转变成全局函数。这些全局函数只能使用内置类型。它们也可以变得通用，即便 Go「没有泛型」。
- 没有运算符重载，那么 == 就会使人感到恼火。因为这意味着你不能在映射中使用自定义类型作为键，除非它们是可比较的。这一属性派生自类型结构，程序员无法重写该属性。

## 总结

Go 是一种简单、小巧、令人愉快的语言。它也有一些犄角旮旯，但绝大部分是经过精心设计的。它的学习速度令人难以置信，并且规避了其他语言中一些不那么广为人知的特性。

Go 也是一种与 Rust 截然不同的语言。虽然两者都可以笼统地描述为「系统语言」或「C 语言的替代品」，但它们的设计目标、应用领域、语言风格和优先级不尽相同。垃圾收集确实带来了一个巨大的差异：使用 GC 使得 Go 变得更简单、更小，也更容易理解。而不使用 GC 使 Rust 奇快无比（特别是在您需要保证延迟，而不仅仅是高吞吐量的时候），并且得以支持 Go 中不可能实现的特性或编程模式（或者至少在不牺牲性能的前提下是无法实现的）。

Go 是一种编译型语言，其运行时得到了良好的实现，其速度毋庸置疑。Rust 也是编译型语言，但是运行时要小得多，它真的迅捷无比。在没有其他限制的情况下，我认为选择使用 Go 还是 Rust 其实意味着一种权衡：一方面，Go 的学习曲线更短、程序更简单（这意味着更快的开发速度）；另一方面，Rust 真的性能卓越，并且类型系统更富有表现力（这使程序更安全，也意味着更快的调试和错误查找）。
